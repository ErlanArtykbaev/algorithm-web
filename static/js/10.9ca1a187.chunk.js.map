{"version":3,"sources":["components/layer/ImageWrapper.js","components/layer/CodePreview.js","assets/img/tree/delete-leaf-1.webp","assets/img/tree/delete-leaf-2.webp","assets/img/tree/delete-leaf-3.webp","assets/img/tree/delete-internal-1.webp","assets/img/tree/delete-internal-2.webp","assets/img/tree/delete-internal_3.webp","components/pages/Tree/DeleteTree.js"],"names":["ImageWrapper","props","className","size","src","url","alt","text","CodePreview","code","language","style","docco","module","exports","DeleteTree","first","second","third","four","five","six"],"mappings":"sHAAA,oBAWeA,IATM,SAACC,GACpB,OACE,yBAAKC,UAAU,iBACb,yBAAKA,UAAWD,EAAME,KAAMC,IAAKH,EAAMI,IAAKC,IAAKL,EAAMI,MACvD,yBAAKH,UAAU,gBAAgBD,EAAMM,S,gCCN3C,sCAeeC,IAVK,SAAC,GAAwB,IAAtBC,EAAqB,EAArBA,KAAMC,EAAe,EAAfA,SAC3B,OACE,yBAAKR,UAAU,QACb,kBAAC,IAAD,CAAmBQ,SAAUA,EAAUC,MAAOC,KAC3CH,M,oBCTTI,EAAOC,QAAU,IAA0B,4C,oBCA3CD,EAAOC,QAAU,IAA0B,4C,oBCA3CD,EAAOC,QAAU,IAA0B,4C,oBCA3CD,EAAOC,QAAU,IAA0B,gD,oBCA3CD,EAAOC,QAAU,IAA0B,gD,oBCA3CD,EAAOC,QAAU,IAA0B,gD,iCCA3C,uJAmhBeC,UAxgBI,WACjB,OACE,yBAAKb,UAAU,aACb,wBAAIA,UAAU,SAAd,0BACA,yMAKA,wLAKA,iGACA,2BACE,2DAEF,6GAIA,2BACE,yDAEF,6GAIA,yBAAKA,UAAU,YACf,wBAAIA,UAAU,aAAd,sBACA,0HAIA,mFACA,sFACA,oGACA,0HAIA,6FACA,wBAAIA,UAAU,iBAAd,UACA,kGACA,yIAIA,mGACwE,KAExE,kBAAC,IAAD,CACEC,KAAK,MACLE,IAAKW,IACLT,KAAK,yCAEP,0OAKA,0KAIA,2FACA,4IAE2C,KAE3C,kBAAC,IAAD,CAAcJ,KAAK,MAAME,IAAKY,IAAQV,KAAK,6BAC3C,wOAKA,qEACA,kBAAC,IAAD,CAAcJ,KAAK,MAAME,IAAKa,IAAOX,KAAK,6BAC1C,wBAAIL,UAAU,iBAAd,WACA,6GAIA,uKAE0E,KAE1E,kBAAC,IAAD,CACEC,KAAK,MACLE,IAAKc,IACLZ,KAAK,mCAEP,uKAIA,mIAKA,kBAAC,IAAD,CACEJ,KAAK,MACLE,IAAKe,IACLb,KAAK,mCAEP,kJAIA,wBAAIL,UAAU,iBAAd,YACA,qbAQA,wPAMA,kBAAC,IAAD,CACEC,KAAK,MACLE,IAAKgB,IACLd,KAAK,mCAEP,yBAAKL,UAAU,YACf,wBAAIA,UAAU,aAAd,gBACA,kBAAC,IAAD,CACEQ,SAAS,OACTD,KAAI,22WAwXN,yBAAKP,UAAU,YACf,wBAAIA,UAAU,aAAd,uBACA,uEACA,uEACA","file":"static/js/10.9ca1a187.chunk.js","sourcesContent":["import React from \"react\"\n\nconst ImageWrapper = (props) => {\n  return (\n    <div className='image-wrapper'>\n      <img className={props.size} src={props.url} alt={props.url} />\n      <div className='image-bottom'>{props.text}</div>\n    </div>\n  )\n}\n\nexport default ImageWrapper\n","import React from \"react\"\n\nimport SyntaxHighlighter from \"react-syntax-highlighter\"\nimport { docco } from \"react-syntax-highlighter/dist/esm/styles/hljs\"\n\nconst CodePreview = ({ code, language }) => {\n  return (\n    <div className='Code'>\n      <SyntaxHighlighter language={language} style={docco}>\n        {code}\n      </SyntaxHighlighter>\n    </div>\n  )\n}\n\nexport default CodePreview\n","module.exports = __webpack_public_path__ + \"static/media/delete-leaf-1.d8058d65.webp\";","module.exports = __webpack_public_path__ + \"static/media/delete-leaf-2.de109216.webp\";","module.exports = __webpack_public_path__ + \"static/media/delete-leaf-3.8b5581e3.webp\";","module.exports = __webpack_public_path__ + \"static/media/delete-internal-1.ef7eb413.webp\";","module.exports = __webpack_public_path__ + \"static/media/delete-internal-2.76874c7b.webp\";","module.exports = __webpack_public_path__ + \"static/media/delete-internal_3.94d286ac.webp\";","import React from \"react\"\nimport ImageWrapper from \"../../layer/ImageWrapper\"\n\nimport first from \"../../../assets/img/tree/delete-leaf-1.webp\"\nimport second from \"../../../assets/img/tree/delete-leaf-2.webp\"\nimport third from \"../../../assets/img/tree/delete-leaf-3.webp\"\nimport four from \"../../../assets/img/tree/delete-internal-1.webp\"\nimport five from \"../../../assets/img/tree/delete-internal-2.webp\"\nimport six from \"../../../assets/img/tree/delete-internal_3.webp\"\nimport CodePreview from \"../../layer/CodePreview\"\n\nconst DeleteTree = () => {\n  return (\n    <div className='container'>\n      <h3 className='title'>Deletion from a B-tree</h3>\n      <p>\n        Deleting an element on a B-tree consists of three main events: searching\n        the node where the key to be deleted exists, deleting the key and\n        balancing the tree if required.\n      </p>\n      <p>\n        While deleting a tree, a condition called underflow may occur. Underflow\n        occurs when a node contains less than the minimum number of keys it\n        should hold.\n      </p>\n      <p>The terms to be understood before studying deletion operation are:</p>\n      <p>\n        <strong>1. Inorder Predecessor</strong>\n      </p>\n      <p>\n        The largest key on the left child of a node is called its inorder\n        predecessor.\n      </p>\n      <p>\n        <strong>2. Inorder Successor</strong>\n      </p>\n      <p>\n        The smallest key on the right child of a node is called its inorder\n        successor.\n      </p>\n      <div className='divider'></div>\n      <h3 className='sub-title'>Deletion Operation</h3>\n      <p>\n        Before going through the steps below, one must know these facts about a\n        B tree of degree m.\n      </p>\n      <p>1. A node can have a maximum of m children. (i.e. 3)</p>\n      <p>2. A node can contain a maximum of m - 1 keys. (i.e. 2)</p>\n      <p>3. A node should have a minimum of ⌈m/2⌉ children. (i.e. 2)</p>\n      <p>\n        4. A node (except root node) should contain a minimum of ⌈m/2⌉ - 1 keys.\n        (i.e. 1)\n      </p>\n      <p>There are three main cases for deletion operation in a B tree.</p>\n      <h3 className='sub-sub-title'>Case I</h3>\n      <p>The key to be deleted lies in the leaf. There are two cases for it.</p>\n      <p>\n        1. The deletion of the key does not violate the property of the minimum\n        number of keys a node should hold.\n      </p>\n      <p>\n        In the tree below, deleting 32 does not violate the above properties.{\" \"}\n      </p>\n      <ImageWrapper\n        size='big'\n        url={first}\n        text='Deleting a leaf key (32) from B-tree'\n      />\n      <p>\n        2. The deletion of the key violates the property of the minimum number\n        of keys a node should hold. In this case, we borrow a key from its\n        immediate neighboring sibling node in the order of left to right.\n      </p>\n      <p>\n        First, visit the immediate left sibling. If the left sibling node has\n        more than a minimum number of keys, then borrow a key from this node.\n      </p>\n      <p>Else, check to borrow from the immediate right sibling node.</p>\n      <p>\n        In the tree below, deleting 31 results in the above condition. Let us\n        borrow a key from the left sibling node.{\" \"}\n      </p>\n      <ImageWrapper size='big' url={second} text='Deleting a leaf key (31)' />\n      <p>\n        If both the immediate sibling nodes already have a minimum number of\n        keys, then merge the node with either the left sibling node or the right\n        sibling node. This merging is done through the parent node.\n      </p>\n      <p>Deleting 30 results in the above case.</p>\n      <ImageWrapper size='big' url={third} text='Deleting a leaf key (30)' />\n      <h3 className='sub-sub-title'>Case II</h3>\n      <p>\n        If the key to be deleted lies in the internal node, the following cases\n        occur.\n      </p>\n      <p>\n        1. The internal node, which is deleted, is replaced by an inorder\n        predecessor if the left child has more than the minimum number of keys.{\" \"}\n      </p>\n      <ImageWrapper\n        size='big'\n        url={four}\n        text='Deleting an internal node (33)'\n      />\n      <p>\n        2. The internal node, which is deleted, is replaced by an inorder\n        successor if the right child has more than the minimum number of keys.\n      </p>\n      <p>\n        3. If either child has exactly a minimum number of keys then, merge the\n        left and the right children.\n      </p>\n\n      <ImageWrapper\n        size='big'\n        url={five}\n        text='Deleting an internal node (30)'\n      />\n      <p>\n        After merging if the parent node has less than the minimum number of\n        keys then, look for the siblings as in Case I.\n      </p>\n      <h3 className='sub-sub-title'>Case III</h3>\n      <p>\n        In this case, the height of the tree shrinks. If the target key lies in\n        an internal node, and the deletion of the key leads to a fewer number of\n        keys in the node (i.e. less than the minimum required), then look for\n        the inorder predecessor and the inorder successor. If both the children\n        contain a minimum number of keys then, borrowing cannot take place. This\n        leads to Case II(3) i.e. merging the children.\n      </p>\n      <p>\n        Again, look for the sibling to borrow a key. But, if the sibling also\n        has only a minimum number of keys then, merge the node with the sibling\n        along with the parent. Arrange the children accordingly (increasing\n        order).\n      </p>\n      <ImageWrapper\n        size='big'\n        url={six}\n        text='Deleting an internal node (10)'\n      />\n      <div className='divider'></div>\n      <h3 className='sub-title'>Java Example</h3>\n      <CodePreview\n        language='java'\n        code={`\n        // Inserting a key on a B-tree in Java\n\n        import java.util.Stack;\n        \n        public class BTree {\n        \n          private int T;\n        \n          public class Node {\n            int n;\n            int key[] = new int[2 * T - 1];\n            Node child[] = new Node[2 * T];\n            boolean leaf = true;\n        \n            public int Find(int k) {\n              for (int i = 0; i < this.n; i++) {\n                if (this.key[i] == k) {\n                  return i;\n                }\n              }\n              return -1;\n            };\n          }\n        \n          public BTree(int t) {\n            T = t;\n            root = new Node();\n            root.n = 0;\n            root.leaf = true;\n          }\n        \n          private Node root;\n        \n          // Search the key\n          private Node Search(Node x, int key) {\n            int i = 0;\n            if (x == null)\n              return x;\n            for (i = 0; i < x.n; i++) {\n              if (key < x.key[i]) {\n                break;\n              }\n              if (key == x.key[i]) {\n                return x;\n              }\n            }\n            if (x.leaf) {\n              return null;\n            } else {\n              return Search(x.child[i], key);\n            }\n          }\n        \n          // Split function\n          private void Split(Node x, int pos, Node y) {\n            Node z = new Node();\n            z.leaf = y.leaf;\n            z.n = T - 1;\n            for (int j = 0; j < T - 1; j++) {\n              z.key[j] = y.key[j + T];\n            }\n            if (!y.leaf) {\n              for (int j = 0; j < T; j++) {\n                z.child[j] = y.child[j + T];\n              }\n            }\n            y.n = T - 1;\n            for (int j = x.n; j >= pos + 1; j--) {\n              x.child[j + 1] = x.child[j];\n            }\n            x.child[pos + 1] = z;\n        \n            for (int j = x.n - 1; j >= pos; j--) {\n              x.key[j + 1] = x.key[j];\n            }\n            x.key[pos] = y.key[T - 1];\n            x.n = x.n + 1;\n          }\n        \n          // Insert the key\n          public void Insert(final int key) {\n            Node r = root;\n            if (r.n == 2 * T - 1) {\n              Node s = new Node();\n              root = s;\n              s.leaf = false;\n              s.n = 0;\n              s.child[0] = r;\n              Split(s, 0, r);\n              _Insert(s, key);\n            } else {\n              _Insert(r, key);\n            }\n          }\n        \n          // Insert the node\n          final private void _Insert(Node x, int k) {\n        \n            if (x.leaf) {\n              int i = 0;\n              for (i = x.n - 1; i >= 0 && k < x.key[i]; i--) {\n                x.key[i + 1] = x.key[i];\n              }\n              x.key[i + 1] = k;\n              x.n = x.n + 1;\n            } else {\n              int i = 0;\n              for (i = x.n - 1; i >= 0 && k < x.key[i]; i--) {\n              }\n              ;\n              i++;\n              Node tmp = x.child[i];\n              if (tmp.n == 2 * T - 1) {\n                Split(x, i, tmp);\n                if (k > x.key[i]) {\n                  i++;\n                }\n              }\n              _Insert(x.child[i], k);\n            }\n        \n          }\n        \n          public void Show() {\n            Show(root);\n          }\n        \n          private void Remove(Node x, int key) {\n            int pos = x.Find(key);\n            if (pos != -1) {\n              if (x.leaf) {\n                int i = 0;\n                for (i = 0; i < x.n && x.key[i] != key; i++) {\n                }\n                ;\n                for (; i < x.n; i++) {\n                  if (i != 2 * T - 2) {\n                    x.key[i] = x.key[i + 1];\n                  }\n                }\n                x.n--;\n                return;\n              }\n              if (!x.leaf) {\n        \n                Node pred = x.child[pos];\n                int predKey = 0;\n                if (pred.n >= T) {\n                  for (;;) {\n                    if (pred.leaf) {\n                      System.out.println(pred.n);\n                      predKey = pred.key[pred.n - 1];\n                      break;\n                    } else {\n                      pred = pred.child[pred.n];\n                    }\n                  }\n                  Remove(pred, predKey);\n                  x.key[pos] = predKey;\n                  return;\n                }\n        \n                Node nextNode = x.child[pos + 1];\n                if (nextNode.n >= T) {\n                  int nextKey = nextNode.key[0];\n                  if (!nextNode.leaf) {\n                    nextNode = nextNode.child[0];\n                    for (;;) {\n                      if (nextNode.leaf) {\n                        nextKey = nextNode.key[nextNode.n - 1];\n                        break;\n                      } else {\n                        nextNode = nextNode.child[nextNode.n];\n                      }\n                    }\n                  }\n                  Remove(nextNode, nextKey);\n                  x.key[pos] = nextKey;\n                  return;\n                }\n        \n                int temp = pred.n + 1;\n                pred.key[pred.n++] = x.key[pos];\n                for (int i = 0, j = pred.n; i < nextNode.n; i++) {\n                  pred.key[j++] = nextNode.key[i];\n                  pred.n++;\n                }\n                for (int i = 0; i < nextNode.n + 1; i++) {\n                  pred.child[temp++] = nextNode.child[i];\n                }\n        \n                x.child[pos] = pred;\n                for (int i = pos; i < x.n; i++) {\n                  if (i != 2 * T - 2) {\n                    x.key[i] = x.key[i + 1];\n                  }\n                }\n                for (int i = pos + 1; i < x.n + 1; i++) {\n                  if (i != 2 * T - 1) {\n                    x.child[i] = x.child[i + 1];\n                  }\n                }\n                x.n--;\n                if (x.n == 0) {\n                  if (x == root) {\n                    root = x.child[0];\n                  }\n                  x = x.child[0];\n                }\n                Remove(pred, key);\n                return;\n              }\n            } else {\n              for (pos = 0; pos < x.n; pos++) {\n                if (x.key[pos] > key) {\n                  break;\n                }\n              }\n              Node tmp = x.child[pos];\n              if (tmp.n >= T) {\n                Remove(tmp, key);\n                return;\n              }\n              if (true) {\n                Node nb = null;\n                int devider = -1;\n        \n                if (pos != x.n && x.child[pos + 1].n >= T) {\n                  devider = x.key[pos];\n                  nb = x.child[pos + 1];\n                  x.key[pos] = nb.key[0];\n                  tmp.key[tmp.n++] = devider;\n                  tmp.child[tmp.n] = nb.child[0];\n                  for (int i = 1; i < nb.n; i++) {\n                    nb.key[i - 1] = nb.key[i];\n                  }\n                  for (int i = 1; i <= nb.n; i++) {\n                    nb.child[i - 1] = nb.child[i];\n                  }\n                  nb.n--;\n                  Remove(tmp, key);\n                  return;\n                } else if (pos != 0 && x.child[pos - 1].n >= T) {\n        \n                  devider = x.key[pos - 1];\n                  nb = x.child[pos - 1];\n                  x.key[pos - 1] = nb.key[nb.n - 1];\n                  Node child = nb.child[nb.n];\n                  nb.n--;\n        \n                  for (int i = tmp.n; i > 0; i--) {\n                    tmp.key[i] = tmp.key[i - 1];\n                  }\n                  tmp.key[0] = devider;\n                  for (int i = tmp.n + 1; i > 0; i--) {\n                    tmp.child[i] = tmp.child[i - 1];\n                  }\n                  tmp.child[0] = child;\n                  tmp.n++;\n                  Remove(tmp, key);\n                  return;\n                } else {\n                  Node lt = null;\n                  Node rt = null;\n                  boolean last = false;\n                  if (pos != x.n) {\n                    devider = x.key[pos];\n                    lt = x.child[pos];\n                    rt = x.child[pos + 1];\n                  } else {\n                    devider = x.key[pos - 1];\n                    rt = x.child[pos];\n                    lt = x.child[pos - 1];\n                    last = true;\n                    pos--;\n                  }\n                  for (int i = pos; i < x.n - 1; i++) {\n                    x.key[i] = x.key[i + 1];\n                  }\n                  for (int i = pos + 1; i < x.n; i++) {\n                    x.child[i] = x.child[i + 1];\n                  }\n                  x.n--;\n                  lt.key[lt.n++] = devider;\n        \n                  for (int i = 0, j = lt.n; i < rt.n + 1; i++, j++) {\n                    if (i < rt.n) {\n                      lt.key[j] = rt.key[i];\n                    }\n                    lt.child[j] = rt.child[i];\n                  }\n                  lt.n += rt.n;\n                  if (x.n == 0) {\n                    if (x == root) {\n                      root = x.child[0];\n                    }\n                    x = x.child[0];\n                  }\n                  Remove(lt, key);\n                  return;\n                }\n              }\n            }\n          }\n        \n          public void Remove(int key) {\n            Node x = Search(root, key);\n            if (x == null) {\n              return;\n            }\n            Remove(root, key);\n          }\n        \n          public void Task(int a, int b) {\n            Stack<Integer> st = new Stack<>();\n            FindKeys(a, b, root, st);\n            while (st.isEmpty() == false) {\n              this.Remove(root, st.pop());\n            }\n          }\n        \n          private void FindKeys(int a, int b, Node x, Stack<Integer> st) {\n            int i = 0;\n            for (i = 0; i < x.n && x.key[i] < b; i++) {\n              if (x.key[i] > a) {\n                st.push(x.key[i]);\n              }\n            }\n            if (!x.leaf) {\n              for (int j = 0; j < i + 1; j++) {\n                FindKeys(a, b, x.child[j], st);\n              }\n            }\n          }\n        \n          public boolean Contain(int k) {\n            if (this.Search(root, k) != null) {\n              return true;\n            } else {\n              return false;\n            }\n          }\n        \n          // Show the node\n          private void Show(Node x) {\n            assert (x == null);\n            for (int i = 0; i < x.n; i++) {\n              System.out.print(x.key[i] + \" \");\n            }\n            if (!x.leaf) {\n              for (int i = 0; i < x.n + 1; i++) {\n                Show(x.child[i]);\n              }\n            }\n          }\n        \n          public static void main(String[] args) {\n            BTree b = new BTree(3);\n            b.Insert(8);\n            b.Insert(9);\n            b.Insert(10);\n            b.Insert(11);\n            b.Insert(15);\n            b.Insert(20);\n            b.Insert(17);\n        \n            b.Show();\n        \n            b.Remove(10);\n            System.out.println();\n            b.Show();\n          }\n        }\n      `}\n      />\n      <div className='divider'></div>\n      <h3 className='sub-title'>Deletion Complexity</h3>\n      <p>Best case Time complexity: Θ(log n)</p>\n      <p>Average case Space complexity: Θ(n)</p>\n      <p>Worst case Space complexity: Θ(n)</p>\n    </div>\n  )\n}\n\nexport default DeleteTree\n"],"sourceRoot":""}