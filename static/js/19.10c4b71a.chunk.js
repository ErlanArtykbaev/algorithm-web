(this["webpackJsonpalgorithm-web"]=this["webpackJsonpalgorithm-web"]||[]).push([[19],{36:function(e,t,n){"use strict";var l=n(0),a=n.n(l);t.a=function(e){return a.a.createElement("div",{className:"image-wrapper"},a.a.createElement("img",{className:e.size,src:e.url,alt:e.url}),a.a.createElement("div",{className:"image-bottom"},e.text))}},37:function(e,t,n){"use strict";var l=n(0),a=n.n(l),u=n(711),r=n(684);t.a=function(e){var t=e.code,n=e.language;return a.a.createElement("div",{className:"Code"},a.a.createElement(u.a,{language:n,style:r.a},t))}},611:function(e,t,n){e.exports=n.p+"static/media/queue.3d69c961.webp"},612:function(e,t,n){e.exports=n.p+"static/media/Big-queue.e41fb8d0.webp"},701:function(e,t,n){"use strict";n.r(t);var l=n(0),a=n.n(l),u=n(36),r=n(611),i=n.n(r),s=n(612),m=n.n(s),o=n(37);t.default=function(){return a.a.createElement("div",{className:"container"},a.a.createElement("h3",{className:"title"},"Queue Data Structure"),a.a.createElement("p",null,"A queue is a useful data structure in programming. It is similar to the ticket queue outside a cinema hall, where the first person entering the queue is the first person who gets the ticket."),a.a.createElement("p",null,"Queue follows the ",a.a.createElement("strong",null,"First In First Out (FIFO)")," rule - the item that goes in first is the item that comes out first. Representation of Queue in first in first out principle"),a.a.createElement(u.a,{size:"big",url:i.a,text:"FIFO Representation of Queue"}),a.a.createElement("p",null,"In the above image, since 1 was kept in the queue before 2, it is the first to be removed from the queue as well. It follows the"," ",a.a.createElement("strong",null,"FIFO"),"rule."),a.a.createElement("p",null,"In programming terms, putting items in the queue is called"," ",a.a.createElement("strong",null,"enqueue"),", and removing items from the queue is called"," ",a.a.createElement("strong",null,"dequeue"),"."),a.a.createElement("p",null,"We can implement the queue in any programming language like C, C++, Java, Python or C#, but the specification is pretty much the same."),a.a.createElement("div",{className:"divider"}),a.a.createElement("h3",{className:"sub-title"},"Basic Operations of Queue"),a.a.createElement("p",null,"A queue is an object (an abstract data structure - ADT) that allows the following operations:"),a.a.createElement("ul",null,a.a.createElement("li",null,a.a.createElement("strong",null,"Enqueue:")," Add an element to the end of the queue"),a.a.createElement("li",null,a.a.createElement("strong",null,"Dequeue:")," Remove an element from the front of the queue"),a.a.createElement("li",null,a.a.createElement("strong",null,"IsEmpty:")," Check if the queue is empty"),a.a.createElement("li",null,a.a.createElement("strong",null,"IsFull:")," Check if the queue is full"),a.a.createElement("li",null,a.a.createElement("strong",null,"Peek:")," Get the value of the front of the queue without removing it")),a.a.createElement("div",{className:"divider"}),a.a.createElement("h3",{className:"sub-title"},"Working of Queue"),a.a.createElement("p",null,"Queue operations work as follows:"),a.a.createElement("ul",null,a.a.createElement("li",null,"two pointers FRONT and REAR"),a.a.createElement("li",null,"FRONT track the first element of the queue"),a.a.createElement("li",null,"REAR track the last element of the queue"),a.a.createElement("li",null,"initially, set value of FRONT and REAR to -1")),a.a.createElement("h3",{className:"sub-title"},"Enqueue Operation"),a.a.createElement("ul",null,a.a.createElement("li",null,"check if the queue is full"),a.a.createElement("li",null,"for the first element, set the value of FRONT to 0"),a.a.createElement("li",null,"increase the REAR index by 1"),a.a.createElement("li",null,"add the new element in the position pointed to by REAR")),a.a.createElement("h3",{className:"sub-title"},"Dequeue Operation"),a.a.createElement("ul",null,a.a.createElement("li",null,"check if the queue is empty"),a.a.createElement("li",null,"return the value pointed by FRONT"),a.a.createElement("li",null,"increase the FRONT index by 1"),a.a.createElement("li",null,"for the last element, reset the values of FRONT and REAR to -1")),a.a.createElement(u.a,{size:"big",url:m.a,text:"Enqueue and Dequeue Operations"}),a.a.createElement("div",{className:"divider"}),a.a.createElement("h3",{className:"sub-title"},"Queue Implementation in Java"),a.a.createElement(o.a,{code:'\n        // Queue implementation in Java\n\n        public class Queue {\n          int SIZE = 5;\n          int items[] = new int[SIZE];\n          int front, rear;\n        \n          Queue() {\n            front = -1;\n            rear = -1;\n          }\n        \n          boolean isFull() {\n            if (front == 0 && rear == SIZE - 1) {\n              return true;\n            }\n            return false;\n          }\n        \n          boolean isEmpty() {\n            if (front == -1)\n              return true;\n            else\n              return false;\n          }\n        \n          void enQueue(int element) {\n            if (isFull()) {\n              System.out.println("Queue is full");\n            } else {\n              if (front == -1)\n                front = 0;\n              rear++;\n              items[rear] = element;\n              System.out.println("Inserted " + element);\n            }\n          }\n        \n          int deQueue() {\n            int element;\n            if (isEmpty()) {\n              System.out.println("Queue is empty");\n              return (-1);\n            } else {\n              element = items[front];\n              if (front >= rear) {\n                front = -1;\n                rear = -1;\n              } /* Q has only one element, so we reset the queue after deleting it. */\n              else {\n                front++;\n              }\n              System.out.println("Deleted -> " + element);\n              return (element);\n            }\n          }\n        \n          void display() {\n            /* Function to display elements of Queue */\n            int i;\n            if (isEmpty()) {\n              System.out.println("Empty Queue");\n            } else {\n              System.out.println("Front index-> " + front);\n              System.out.println("Items -> ");\n              for (i = front; i <= rear; i++)\n                System.out.print(items[i] + "  ");\n        \n              System.out.println("Rear index-> " + rear);\n            }\n          }\n        \n          public static void main(String[] args) {\n            Queue q = new Queue();\n        \n            // deQueue is not possible on empty queue\n            q.deQueue();\n        \n            // enQueue 5 elements\n            q.enQueue(1);\n            q.enQueue(2);\n            q.enQueue(3);\n            q.enQueue(4);\n            q.enQueue(5);\n        \n            // 6th element can\'t be added to because the queue is full\n            q.enQueue(6);\n        \n            q.display();\n        \n            // deQueue removes element entered first i.e. 1\n            q.deQueue();\n        \n            // Now we have just 4 elements\n            q.display();\n        \n          }\n        }\n      '}))}}}]);
//# sourceMappingURL=19.10c4b71a.chunk.js.map