{"version":3,"sources":["containers/algorythms/BinaryTree/components/Controls/Controls.js","containers/algorythms/BinaryTree/components/Visualizer/TraversedList.js","containers/algorythms/BinaryTree/components/Visualizer/Visualizer.js","containers/algorythms/BinaryTree/lib/tree.js","containers/algorythms/BinaryTree/lib/animateNodeInTree.js","containers/algorythms/BinaryTree/BinaryTreeVisual.js","components/pages/Tree/TreeExample.js"],"names":["Controls","selectedTraversal","handleChange","className","name","value","onChange","options","label","clearable","TraversedList","delayedList","TransitionGroup","component","map","num","index","CSSTransition","key","timeout","classNames","Visualizer","data","height","width","svgProps","transform","textProps","animated","Node","node","this","left","right","BinaryTree","val","root","traverseList","insert","dir","newNode","insertAt","nodepos","levelordertraverse","search","queue","current","push","length","shift","preorder","postorder","inorder","getTraversed","animateNodeInTree","children","forEach","element","hasOwnProperty","circleProps","fill","BinaryTreeVisual","props","state","traversedList","delayList","bind","updateTree","animate","tree","resetTreeDiagram","listItem","setTimeout","setState","String","updatedTreeData","Component","TreeExample"],"mappings":"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","file":"static/js/11.a94814b4.chunk.js","sourcesContent":["import React from \"react\"\nimport Select from \"react-select\"\n\nimport \"./Controls.css\"\n\nconst Controls = ({ selectedTraversal, handleChange }) => (\n  <div className='controls-container'>\n    <Select\n      name='sort-select'\n      value={selectedTraversal && selectedTraversal.value}\n      onChange={handleChange}\n      className='select-field'\n      options={[\n        { label: \"preorder\", value: \"preorder\" },\n        { label: \"inorder\", value: \"inorder\" },\n        { label: \"postorder\", value: \"postorder\" },\n        { label: \"level order\", value: \"level order\" },\n      ]}\n      clearable={false}\n    />\n  </div>\n)\n\nexport default Controls\n","import React from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\n\nimport \"./TraversedList.css\";\n\n// Renders the list of nodes passed in as props and add transition on enter and exit using React Transition group\nconst TraversedList = ({ delayedList }) => (\n  <div className=\"numbers-container\">\n    <ul className=\"numbers-list\">\n      <TransitionGroup component={null}>\n        {delayedList.map((num, index) => (\n          <CSSTransition key={index} timeout={500} classNames=\"fade\">\n            <li className=\"numbers-list-item\" key={index}>\n              {num}\n            </li>\n          </CSSTransition>\n        ))}\n      </TransitionGroup>\n    </ul>\n  </div>\n);\n\nexport default TraversedList;\n","import React from \"react\";\nimport Tree from \"react-tree-graph\";\n\nimport TraversedList from \"./TraversedList\";\n\nimport \"./Visualizer.css\";\n\nconst Visualizer = ({ data, delayedList }) => (\n  <div className=\"visualizer-container\">\n    {/* Render Tree with data passed as prop */}\n    <Tree\n      data={data}\n      height={400}\n      width={400}\n      svgProps={{\n        transform: \"rotate(90)\"\n      }}\n      textProps={{\n        transform: \"rotate(270)\"\n      }}\n      animated={true}\n    />\n    {/* Render List of traversed nodes passed as prop */}\n    <TraversedList delayedList={delayedList} />\n  </div>\n);\n\nexport default Visualizer;\n","// The tree data structure file for the app to store nodes and performing traversal\n\nfunction Node(node) {\n  // Constructor function to create a node\n  this.node = node;\n  this.left = null;\n  this.right = null;\n}\n\nfunction BinaryTree(val) {\n  // Constructor function to create a Binary tree\n  this.root = null;\n  this.traverseList = [];\n  if (typeof val !== \"undefined\") {\n    this.root = new Node(val);\n  } else {\n    throw \"root is empty\";\n  }\n  this.insert = function(val, dir) {\n    // Insert node at root to left or right provided as dir\n    const newNode = new Node(val);\n    this.root[dir] = newNode;\n  };\n  this.insertAt = function(node, val, dir) {\n    // Insert node at specified node to left or right provided as dir\n    const nodepos = this.levelordertraverse(node); // Makes use of levelordertraverse api to find the node and insert new node\n    const newNode = new Node(val);\n    nodepos[dir] = newNode;\n  };\n  this.levelordertraverse = function(search = -1) {\n    // Perform levelorder traversel to return the traversed list or support insertAt api. \n    // If search=-1 then returns traversed list else return the node that was to be searched.\n    const queue = [];\n    var current = this.root;\n    queue.push(current);\n    if (this.traverseList.length > 0) this.traverseList = [];\n    while (queue.length > 0) {\n      current = queue.shift();\n      if (current !== null) {\n        if (search === -1) {\n          this.traverseList.push(current.node);\n        }\n        if (current.node === search && search !== -1) {\n          return current;\n        }\n        if (current.left !== null) {\n          queue.push(current.left);\n        }\n        if (current.right !== null) {\n          queue.push(current.right);\n        }\n      }\n    }\n  };\n  this.preorder = function(node = this.root) { // Perform preorder traversal of the tree\n    if (node === this.root && this.traverseList.length > 0)\n      this.traverseList = [];\n    if (node !== null) {\n      this.traverseList.push(node.node);\n      this.preorder(node.left);\n      this.preorder(node.right);\n    }\n  };\n  this.postorder = function(node = this.root) { // Perform postorder traversal of the tree\n    if (node === this.root && this.traverseList.length > 0)\n      this.traverseList = [];\n    if (node !== null) {\n      this.postorder(node.left);\n      this.postorder(node.right);\n      this.traverseList.push(node.node);\n    }\n  };\n  this.inorder = function(node = this.root) { // Perform inorder traversal of the tree\n    if (node === this.root && this.traverseList.length > 0)\n      this.traverseList = [];\n    if (node !== null) {\n      this.inorder(node.left);\n      this.traverseList.push(node.node);\n      this.inorder(node.right);\n    }\n  };\n  this.getTraversed = function() { // Get the list of traversed nodes after calling any traversal api\n    return this.traverseList;\n  };\n}\nexport default BinaryTree;\n","function animateNodeInTree(data, node) { \n  // Traverse the `data` provided to the Tree diagram and find the current `node` being traversed as per the traversedlist.\n  // Change the color the node by adding a circleProps property to the node object.\n    const children = data.children;\n    children.forEach(element => {\n      if (element.name === node) {\n        element.circleProps = {\n          fill: \"red\"\n        };\n        return;\n      } else if (element.hasOwnProperty(\"children\")) {\n        animateNodeInTree(element, node);\n      }\n    });\n    return data;\n}\n\nexport default animateNodeInTree;\n","import React, { Component } from \"react\"\n\nimport { Controls, Visualizer } from \"./components\"\n\nimport BinaryTree from \"./lib/tree\"\nimport animateNodeInTree from \"./lib/animateNodeInTree\"\n\nimport \"./App.css\"\n\nclass BinaryTreeVisual extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      traversedList: [],\n      delayedList: [],\n      data: {\n        name: \"34\",\n        children: [\n          {\n            name: \"92\",\n          },\n          {\n            name: \"23\",\n            children: [\n              {\n                name: \"04\",\n                children: [\n                  {\n                    name: \"09\",\n                  },\n                  { name: \"16\" },\n                ],\n              },\n              {\n                name: \"12\",\n              },\n            ],\n          },\n        ],\n      },\n      selectedTraversal: \"\",\n    }\n    this.delayList = this.delayList.bind(this)\n    this.updateTree = this.updateTree.bind(this)\n    this.handleChange = this.handleChange.bind(this)\n    this.animate = this.animate.bind(this)\n    this.tree = new BinaryTree(\"34\") // Initialize Tree instance\n    this.resetTreeDiagram = this.resetTreeDiagram.bind(this)\n  }\n\n  componentDidMount() {\n    this.tree.insert(\"23\", \"left\")\n    this.tree.insert(\"92\", \"right\")\n    this.tree.insertAt(\"23\", \"12\", \"left\") // Api to insert a node at a specific node\n    this.tree.insertAt(\"23\", \"04\", \"right\")\n    this.tree.insertAt(\"04\", \"16\", \"left\")\n    this.tree.insertAt(\"04\", \"09\", \"right\")\n  }\n\n  delayList() {\n    // Render the list of traversed node with some delay to appear animated\n    const { traversedList } = this.state\n    traversedList.forEach((listItem, index) => {\n      setTimeout(() => {\n        this.setState({ delayedList: [...this.state.delayedList, listItem] })\n        this.updateTree(listItem)\n      }, 1500 * index)\n    })\n  }\n\n  updateTree(node) {\n    // Update the data provided to the tree diagram (changes color of the current node being traversed)\n    const { data } = this.state\n    if (data.name === String(node)) {\n      data.circleProps = { fill: \"red\" }\n      this.setState({ data })\n    } else {\n      const updatedTreeData = animateNodeInTree(this.state.data, String(node))\n      this.setState({ data: updatedTreeData })\n    }\n  }\n\n  handleChange(selectedTraversal) {\n    this.setState(\n      { selectedTraversal, delayedList: [], traversedList: [] },\n      () => {\n        this.resetTreeDiagram()\n      }\n    )\n  }\n\n  animate() {\n    // Perform selected traversal and trigger animation\n    const { selectedTraversal } = this.state\n    if (selectedTraversal.value === \"inorder\") {\n      this.tree.inorder()\n    } else if (selectedTraversal.value === \"preorder\") {\n      this.tree.preorder()\n    } else if (selectedTraversal.value === \"postorder\") {\n      this.tree.postorder()\n    } else this.tree.levelordertraverse()\n    const traversedList = this.tree.getTraversed()\n    this.setState({ traversedList }, () => {\n      this.delayList()\n    })\n  }\n\n  resetTreeDiagram() {\n    // Resets the tree diagram with red nodes back to tree with black nodes\n    const data = {\n      name: \"34\",\n      children: [\n        {\n          name: \"92\",\n        },\n        {\n          name: \"23\",\n          children: [\n            {\n              name: \"04\",\n              children: [\n                {\n                  name: \"09\",\n                },\n                { name: \"16\" },\n              ],\n            },\n            {\n              name: \"12\",\n            },\n          ],\n        },\n      ],\n    }\n    this.setState({ data }, () => {\n      this.animate()\n    })\n  }\n\n  render() {\n    return (\n      <div className='main-container'>\n        <Visualizer\n          data={this.state.data}\n          delayedList={this.state.delayedList}\n        />\n        <Controls\n          selectedTraversal={this.state.selectedTraversal}\n          handleChange={this.handleChange}\n        />\n      </div>\n    )\n  }\n}\n\nexport default BinaryTreeVisual\n","import React from \"react\"\nimport BinaryTreeVisual from \"../../../containers/algorythms/BinaryTree/BinaryTreeVisual\"\n\nconst TreeExample = () => {\n  return (\n    <div className='container'>\n      <h3 className='title'>Visual Example of Binary Tree</h3>\n      <BinaryTreeVisual />\n    </div>\n  )\n}\n\nexport default TreeExample\n"],"sourceRoot":""}