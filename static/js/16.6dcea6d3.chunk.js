(this["webpackJsonpalgorithm-web"]=this["webpackJsonpalgorithm-web"]||[]).push([[16],{36:function(e,a,t){"use strict";var n=t(0),l=t.n(n);a.a=function(e){return l.a.createElement("div",{className:"image-wrapper"},l.a.createElement("img",{className:e.size,src:e.url,alt:e.url}),l.a.createElement("div",{className:"image-bottom"},e.text))}},37:function(e,a,t){"use strict";var n=t(0),l=t.n(n),s=t(711),i=t(684);a.a=function(e){var a=e.code,t=e.language;return l.a.createElement("div",{className:"Code"},l.a.createElement(s.a,{language:t,style:i.a},a))}},528:function(e,a,t){e.exports=t.p+"static/media/Hash-0.3fbc5cc3.webp"},529:function(e,a,t){e.exports=t.p+"static/media/Hash-2_0.007a84d4.webp"},530:function(e,a,t){e.exports=t.p+"static/media/Hash-3_1.0147e9ad.webp"},696:function(e,a,t){"use strict";t.r(a);var n=t(0),l=t.n(n),s=t(36),i=t(528),r=t.n(i),c=t(529),m=t.n(c),o=t(530),h=t.n(o),u=t(37);a.default=function(){return l.a.createElement("div",{className:"container"},l.a.createElement("h3",{className:"title"},"Hash Table"),l.a.createElement("p",null,"The Hash table data structure stores elements in key-value pairs where"),l.a.createElement("ul",null,l.a.createElement("li",null,l.a.createElement("strong",null,"Key - ")," unique integer that is used for indexing the values"),l.a.createElement("li",null,l.a.createElement("strong",null,"Value - ")," data that are associated with keys.")),l.a.createElement(s.a,{size:"sm",url:r.a,text:"Key and Value in Hash table"}),l.a.createElement("div",{className:"divider"}),l.a.createElement("h3",{className:"sub-title"},"Hashing (Hash Function)"),l.a.createElement("p",null,"In a hash table, a new index is processed using the keys. And, the element corresponding to that key is stored in the index. This process is called hashing."),l.a.createElement("p",null,"Let ",l.a.createElement("span",{className:"var"},"k")," be a key and"," ",l.a.createElement("span",{className:"var"},"h(x)"),"be a hash function."),l.a.createElement("p",null,"Here, ",l.a.createElement("span",{className:"var"},"h(k)")," will give us a new index to store the element linked with ",l.a.createElement("span",{className:"var"},"k"),"."),l.a.createElement(s.a,{size:"big",url:m.a,text:"Hash table Representation"}),l.a.createElement("div",{className:"divider"}),l.a.createElement("h3",{className:"sub-title"},"Hash Collision"),l.a.createElement("p",null,"When the hash function generates the same index for multiple keys, there will be a conflict (what value to be stored in that index). This is called a hash collision."),l.a.createElement("p",null,"We can resolve the hash collision using one of the following techniques."),l.a.createElement("ul",null,l.a.createElement("li",null,"Collision resolution by chaining"),l.a.createElement("li",null,"Open Addressing: Linear/Quadratic Probing and Double Hashing")),l.a.createElement("div",{className:"divider"}),l.a.createElement("h3",{className:"sub-title"},"1. Collision resolution by chaining"),l.a.createElement("p",null,"In chaining, if a hash function produces the same index for multiple elements, these elements are stored in the same index by using a doubly-linked list."),l.a.createElement("p",null,"If ",l.a.createElement("span",{className:"var"},"j")," is the slot for multiple elements, it contains a pointer to the head of the list of elements. If no element is present, ",l.a.createElement("span",{className:"var"},"j")," contains"," ",l.a.createElement("span",{className:"var"},"NIL"),"."),l.a.createElement(s.a,{size:"big",url:h.a,text:"Collision Resolution using chaining"}),l.a.createElement("div",{className:"divider"}),l.a.createElement("h3",{className:"sub-title"},"2. Open Addressing"),l.a.createElement("p",null,"Unlike chaining, open addressing doesn't store multiple elements into the same slot. Here, each slot is either filled with a single key or left ",l.a.createElement("span",{className:"var"},"NIL"),"."),l.a.createElement("p",null,"Different techniques used in open addressing are:"),l.a.createElement("h3",{className:"sub-sub-title"},"i. Linear Probing"),l.a.createElement("p",null,"In linear probing, collision is resolved by checking the next slot."),l.a.createElement("p",null,l.a.createElement("span",{className:"var"},"h(k, i) = (h\u2032(k) + i) mod m")),l.a.createElement("p",null,"where"),l.a.createElement("ul",null,l.a.createElement("li",null,l.a.createElement("span",{className:"var"},"i = {0, 1, \u2026.}")),l.a.createElement("li",null,l.a.createElement("span",{className:"var"},"h'(k)")," is a new hash function")),l.a.createElement("p",null,"If a collision occurs at ",l.a.createElement("span",{className:"var"},"h(k, 0)"),", then"," ",l.a.createElement("span",{className:"var"},"h(k, 1)")," is checked. In this way, the value of i is incremented linearly."),l.a.createElement("p",null,"The problem with linear probing is that a cluster of adjacent slots is filled. When inserting a new element, the entire cluster must be traversed. This adds to the time required to perform operations on the hash table."),l.a.createElement("h3",{className:"sub-sub-title"},"ii. Quadratic Probing"),l.a.createElement("p",null,"It works similar to linear probing but the spacing between the slots is increased (greater than one) by using the following relation."),l.a.createElement("p",null,l.a.createElement("span",{className:"var"},"h(k, i) = (h\u2032(k) + c1i + c2i2) mod m")),l.a.createElement("p",null,"where,"),l.a.createElement("ul",null,l.a.createElement("li",null,"c1 and c2 are positive auxiliary constants,"),l.a.createElement("li",null,l.a.createElement("span",{className:"var"},"i = {0, 1, \u2026.}"))),l.a.createElement("h3",{className:"sub-sub-title"},"iii. Double hashing"),l.a.createElement("p",null,"If a collision occurs after applying a hash function h(k), then another hash function is calculated for finding the next slot."),l.a.createElement("p",null,l.a.createElement("span",{className:"var"},"h(k, i) = (h1(k) + ih2(k)) mod m")),l.a.createElement("div",{className:"divider"}),l.a.createElement("h3",{className:"sub-title"},"Good Hash Functions"),l.a.createElement("p",null,"A good hash function may not prevent the collisions completely however it can reduce the number of collisions."),l.a.createElement("p",null,"Here, we will look into different methods to find a good hash function"),l.a.createElement("h3",{className:"sub-sub-title"},"1. Division Method"),l.a.createElement("p",null,"If k is a key and m is the size of the hash table, the hash function h() is calculated as:"),l.a.createElement("p",null,l.a.createElement("span",null,"h(k) = k mod m")),l.a.createElement("p",null,"For example, If the size of a hash table is"," ",l.a.createElement("span",{className:"var"},"10")," and ",l.a.createElement("span",{className:"var"},"k = 12")," ","then ",l.a.createElement("span",{className:"var"},"h(k) = 112")," mod"," ",l.a.createElement("span",{className:"var"},"10 = 2"),". The value of"," ",l.a.createElement("span",{className:"var"},"m")," must not be the powers of"," ",l.a.createElement("span",{className:"var"},"2"),". This because the powers of"," ",l.a.createElement("span",{className:"bar"},"2")," in binary format are"," ",l.a.createElement("span",{className:"var"},"10, 100, 1000, ..."),". When we find k mod m, we will always get the lower order p-bits."),l.a.createElement(u.a,{code:"\n        if m = 22, k = 17, then h(k) = 17 mod 22 = 10001 mod 100 = 01\n        if m = 23, k = 17, then h(k) = 17 mod 22 = 10001 mod 100 = 001\n        if m = 24, k = 17, then h(k) = 17 mod 22 = 10001 mod 100 = 0001\n        if m = 2p, then h(k) = p lower bits of m\n        ",language:"c"}),l.a.createElement("h3",{className:"sub-sub-title"},"2. Multiplication Method"),l.a.createElement("p",null,l.a.createElement("span",{className:"var"},"h(k) = \u230am(kA mod 1)\u230b")),l.a.createElement("p",null,"where, "),l.a.createElement("ul",null,l.a.createElement("li",null,l.a.createElement("span",{className:"var"},"kA mod 1")," gives the fractional part"," ",l.a.createElement("span",{className:"var"},"kA"),","),l.a.createElement("li",null,l.a.createElement("span",{className:"var"},"\u230a \u230b")," gives the floor value"),l.a.createElement("li",null,l.a.createElement("span",{className:"var"},"A")," is any constant. The value of A lies between 0 and 1. But, an optimal choice will be"," ",l.a.createElement("span",{className:"var"},"\u2248 (\u221a5-1)/2")," suggested by Knuth.")),l.a.createElement("h3",{className:"sub-sub-title"},"3. Universal Hashing"),l.a.createElement("p",null,"In Universal hashing, the hash function is chosen at random independent of keys."),l.a.createElement("div",{className:"divider"}),l.a.createElement("h3",{className:"sub-title"},"Java Example"),l.a.createElement(u.a,{code:"\n        // Java program to demonstrate working of HashTable \n\n        import java.util.*; \n        \n        class HashTable { \n          public static void main(String args[]) \n          {\n          Hashtable<Integer, Integer> \n            ht = new Hashtable<Integer, Integer>(); \n          \n          ht.put(123, 432); \n          ht.put(12, 2345);\n          ht.put(15, 5643); \n          ht.put(3, 321);\n        \n          ht.remove(12);\n        \n          System.out.println(ht); \n          } \n        } \n        ",language:"java"}))}}}]);
//# sourceMappingURL=16.6dcea6d3.chunk.js.map