(this["webpackJsonpalgorithm-web"]=this["webpackJsonpalgorithm-web"]||[]).push([[25],{36:function(e,n,t){"use strict";var i=t(0),a=t.n(i);n.a=function(e){return a.a.createElement("div",{className:"image-wrapper"},a.a.createElement("img",{className:e.size,src:e.url,alt:e.url}),a.a.createElement("div",{className:"image-bottom"},e.text))}},37:function(e,n,t){"use strict";var i=t(0),a=t.n(i),l=t(731),r=t(700);n.a=function(e){var n=e.code,t=e.language;return a.a.createElement("div",{className:"Code"},a.a.createElement(l.a,{language:t,style:r.a},n))}},641:function(e,n,t){e.exports=t.p+"static/media/insertion.f34cac96.webp"},723:function(e,n,t){"use strict";t.r(n);var i=t(0),a=t.n(i),l=t(36),r=t(641),s=t.n(r),o=t(37);n.default=function(){return a.a.createElement("div",{className:"container"},a.a.createElement("h3",{className:"title"},"Insertion into a B-tree"),a.a.createElement("p",null,"Inserting an element on a B-tree consists of two events: searching the appropriate node to insert the element and splitting the node if required.Insertion operation always takes place in the bottom-up approach."),a.a.createElement("p",null,"Let us understand these events below."),a.a.createElement("div",{className:"divider"}),a.a.createElement("div",{className:"sub-title"},"Insertion Operation"),a.a.createElement("p",null,"1. If the tree is empty, allocate a root node and insert the key."),a.a.createElement("p",null,"2. Update the allowed number of keys in the node."),a.a.createElement("p",null,"3. Search the appropriate node for insertion."),a.a.createElement("p",null,"4. If the node is full, follow the steps below."),a.a.createElement("p",null,"5. Insert the elements in increasing order."),a.a.createElement("p",null,"6. Now, there are elements greater than its limit. So, split at the median."),a.a.createElement("p",null,"7. Push the median key upwards and make the left keys as a left child and the right keys as a right child."),a.a.createElement("p",null,"8. If the node is not full, follow the steps below."),a.a.createElement("p",null,"9. Insert the node in increasing order."),a.a.createElement("div",{className:"divider"}),a.a.createElement("h3",{className:"sub-title"},"Insertion Example"),a.a.createElement("p",null,"Let us understand the insertion operation with the illustrations below."),a.a.createElement("p",null,"The elements to be inserted are 8, 9, 10, 11, 15, 16, 17, 18, 20, 23."),a.a.createElement(l.a,{size:"big",url:s.a,text:"Inserting elements into a B-tree"}),a.a.createElement("div",{className:"divider"}),a.a.createElement("h3",{className:"sub-title"},"Algorithm for Inserting an Element"),a.a.createElement(o.a,{code:"\n        BreeInsertion(T, k)\n        r  root[T]\n        if n[r] = 2t - 1\n            s = AllocateNode()\n            root[T] = s\n            leaf[s] = FALSE\n            n[s] <- 0\n            c1[s] <- r\n            BtreeSplitChild(s, 1, r)\n            BtreeInsertNonFull(s, k)\n        else BtreeInsertNonFull(r, k)\n        BtreeInsertNonFull(x, k)\n        i = n[x]\n        if leaf[x]\n            while i \u2265 1 and k < keyi[x]\n                keyi+1 [x] = keyi[x]\n                i = i - 1\n            keyi+1[x] = k\n            n[x] = n[x] + 1\n        else while i \u2265 1 and k < keyi[x]\n                i = i - 1\n            i = i + 1\n            if n[ci[x]] == 2t - 1\n                BtreeSplitChild(x, i, ci[x])\n                if k &rt; keyi[x]\n                    i = i + 1\n            BtreeInsertNonFull(ci[x], k)\n        BtreeSplitChild(x, i)\n        BtreeSplitChild(x, i, y)\n        z = AllocateNode()\n        leaf[z] = leaf[y]\n        n[z] = t - 1\n        for j = 1 to t - 1\n            keyj[z] = keyj+t[y]\n        if not leaf [y]\n            for j = 1 to t\n                cj[z] = cj + t[y]\n        n[y] = t - 1\n        for j = n[x] + 1 to i + 1\n            cj+1[x] = cj[x]\n        ci+1[x] = z\n        for j = n[x] to i\n            keyj+1[x] = keyj[x]\n        keyi[x] = keyt[y]\n        n[x] = n[x] + 1\n        ",language:"c"}),a.a.createElement("div",{className:"divider"}),a.a.createElement("h3",{className:"sub-title"},"Java Example"),a.a.createElement(o.a,{code:'\n        // Inserting a key on a B-tree in Java \n\n        public class BTree {\n        \n          private int T;\n        \n          // Node Creation\n          public class Node {\n            int n;\n            int key[] = new int[2 * T - 1];\n            Node child[] = new Node[2 * T];\n            boolean leaf = true;\n        \n            public int Find(int k) {\n              for (int i = 0; i < this.n; i++) {\n                if (this.key[i] == k) {\n                  return i;\n                }\n              }\n              return -1;\n            };\n          }\n        \n          public BTree(int t) {\n            T = t;\n            root = new Node();\n            root.n = 0;\n            root.leaf = true;\n          }\n        \n          private Node root;\n        \n          // split\n          private void split(Node x, int pos, Node y) {\n            Node z = new Node();\n            z.leaf = y.leaf;\n            z.n = T - 1;\n            for (int j = 0; j < T - 1; j++) {\n              z.key[j] = y.key[j + T];\n            }\n            if (!y.leaf) {\n              for (int j = 0; j < T; j++) {\n                z.child[j] = y.child[j + T];\n              }\n            }\n            y.n = T - 1;\n            for (int j = x.n; j >= pos + 1; j--) {\n              x.child[j + 1] = x.child[j];\n            }\n            x.child[pos + 1] = z;\n        \n            for (int j = x.n - 1; j >= pos; j--) {\n              x.key[j + 1] = x.key[j];\n            }\n            x.key[pos] = y.key[T - 1];\n            x.n = x.n + 1;\n          }\n        \n          // insert key\n          public void insert(final int key) {\n            Node r = root;\n            if (r.n == 2 * T - 1) {\n              Node s = new Node();\n              root = s;\n              s.leaf = false;\n              s.n = 0;\n              s.child[0] = r;\n              split(s, 0, r);\n              _insert(s, key);\n            } else {\n              _insert(r, key);\n            }\n          }\n        \n          // insert node\n          final private void _insert(Node x, int k) {\n        \n            if (x.leaf) {\n              int i = 0;\n              for (i = x.n - 1; i >= 0 && k < x.key[i]; i--) {\n                x.key[i + 1] = x.key[i];\n              }\n              x.key[i + 1] = k;\n              x.n = x.n + 1;\n            } else {\n              int i = 0;\n              for (i = x.n - 1; i >= 0 && k < x.key[i]; i--) {\n              }\n              ;\n              i++;\n              Node tmp = x.child[i];\n              if (tmp.n == 2 * T - 1) {\n                split(x, i, tmp);\n                if (k > x.key[i]) {\n                  i++;\n                }\n              }\n              _insert(x.child[i], k);\n            }\n        \n          }\n        \n          public void display() {\n            display(root);\n          }\n        \n          // Display the tree\n          private void display(Node x) {\n            assert (x == null);\n            for (int i = 0; i < x.n; i++) {\n              System.out.print(x.key[i] + " ");\n            }\n            if (!x.leaf) {\n              for (int i = 0; i < x.n + 1; i++) {\n                display(x.child[i]);\n              }\n            }\n          }\n        \n          public static void main(String[] args) {\n            BTree b = new BTree(3);\n            b.insert(8);\n            b.insert(9);\n            b.insert(10);\n            b.insert(11);\n            b.insert(15);\n            b.insert(20);\n            b.insert(17);\n        \n            b.display();\n          }\n        }\n        ',language:"java"}))}}}]);
//# sourceMappingURL=25.905ecf94.chunk.js.map