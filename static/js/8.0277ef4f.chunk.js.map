{"version":3,"sources":["components/layer/ImageWrapper.js","components/layer/CodePreview.js","assets/img/graph/graph-dfs-step-0.webp","assets/img/graph/graph-dfs-step-1.webp","assets/img/graph/graph-dfs-step-2.webp","assets/img/graph/graph-dfs-step-3.webp","assets/img/graph/graph-dfs-step-4.webp","assets/img/graph/graph-dfs-step-5.webp","assets/img/graph/shortest-subpath.webp","assets/img/graph/dj-1.webp","assets/img/graph/dj-2.webp","assets/img/graph/dj-3.webp","assets/img/graph/dj-4.webp","assets/img/graph/dj-5.webp","assets/img/graph/dj-6.webp","assets/img/graph/dj-7.webp","assets/img/graph/dj-8.webp","components/pages/Graph/GraphAlgorithms.js"],"names":["ImageWrapper","props","className","size","src","url","alt","text","CodePreview","code","language","style","docco","module","exports","GraphAlgorithms","first","second","third","fourth","fifth","sixth","class","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen"],"mappings":"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","file":"static/js/8.0277ef4f.chunk.js","sourcesContent":["import React from \"react\"\n\nconst ImageWrapper = (props) => {\n  return (\n    <div className='image-wrapper'>\n      <img className={props.size} src={props.url} alt={props.url} />\n      <div className='image-bottom'>{props.text}</div>\n    </div>\n  )\n}\n\nexport default ImageWrapper\n","import React from \"react\"\n\nimport SyntaxHighlighter from \"react-syntax-highlighter\"\nimport { docco } from \"react-syntax-highlighter/dist/esm/styles/hljs\"\n\nconst CodePreview = ({ code, language }) => {\n  return (\n    <div className='Code'>\n      <SyntaxHighlighter language={language} style={docco}>\n        {code}\n      </SyntaxHighlighter>\n    </div>\n  )\n}\n\nexport default CodePreview\n","module.exports = __webpack_public_path__ + \"static/media/graph-dfs-step-0.e258a0e6.webp\";","module.exports = __webpack_public_path__ + \"static/media/graph-dfs-step-1.18f8dbb7.webp\";","module.exports = __webpack_public_path__ + \"static/media/graph-dfs-step-2.81ad5fe3.webp\";","module.exports = __webpack_public_path__ + \"static/media/graph-dfs-step-3.d39953d2.webp\";","module.exports = __webpack_public_path__ + \"static/media/graph-dfs-step-4.92a5288a.webp\";","module.exports = __webpack_public_path__ + \"static/media/graph-dfs-step-5.e5325d0b.webp\";","module.exports = __webpack_public_path__ + \"static/media/shortest-subpath.d6e23ac0.webp\";","module.exports = __webpack_public_path__ + \"static/media/dj-1.770ba013.webp\";","module.exports = __webpack_public_path__ + \"static/media/dj-2.9ee1986f.webp\";","module.exports = __webpack_public_path__ + \"static/media/dj-3.3bb39aac.webp\";","module.exports = __webpack_public_path__ + \"static/media/dj-4.c4827872.webp\";","module.exports = __webpack_public_path__ + \"static/media/dj-5.4adf2828.webp\";","module.exports = __webpack_public_path__ + \"static/media/dj-6.8593b33e.webp\";","module.exports = __webpack_public_path__ + \"static/media/dj-7.6d27541d.webp\";","module.exports = __webpack_public_path__ + \"static/media/dj-8.32b686e9.webp\";","import React from \"react\";\nimport ImageWrapper from \"../../layer/ImageWrapper\";\nimport CodePreview from \"../../layer/CodePreview\";\n\nimport first from \"../../../assets/img/graph/graph-dfs-step-0.webp\";\nimport second from \"../../../assets/img/graph/graph-dfs-step-1.webp\";\nimport third from \"../../../assets/img/graph/graph-dfs-step-2.webp\";\nimport fourth from \"../../../assets/img/graph/graph-dfs-step-3.webp\";\nimport fifth from \"../../../assets/img/graph/graph-dfs-step-4.webp\";\nimport sixth from \"../../../assets/img/graph/graph-dfs-step-5.webp\";\nimport seven from \"../../../assets/img/graph/shortest-subpath.webp\";\nimport eight from \"../../../assets/img/graph/dj-1.webp\";\nimport nine from \"../../../assets/img/graph/dj-2.webp\";\nimport ten from \"../../../assets/img/graph/dj-3.webp\";\nimport eleven from \"../../../assets/img/graph/dj-4.webp\";\nimport twelve from \"../../../assets/img/graph/dj-5.webp\";\nimport thirteen from \"../../../assets/img/graph/dj-6.webp\";\nimport fourteen from \"../../../assets/img/graph/dj-7.webp\";\nimport fifteen from \"../../../assets/img/graph/dj-8.webp\";\n\nconst GraphAlgorithms = () => {\n  return (\n    <div className=\"container\">\n      <h3 className=\"title\">Algorithms on Graphs</h3>\n      <h3 className=\"sub-title\">Depth First Search (DFS)</h3>\n      <p>\n        Depth first Search or Depth first traversal is a recursive algorithm for\n        searching all the vertices of a graph or tree data structure. Traversal\n        means visiting all the nodes of a graph.\n      </p>\n      <div className=\"divider\"></div>\n      <h3 className=\"sub-title\">Depth First Search Algorithm</h3>\n      <p>\n        A standard DFS implementation puts each vertex of the graph into one of\n        two categories:\n      </p>\n      <p>1. Visited</p>\n      <p>2. Not Visited</p>\n      <p>\n        The purpose of the algorithm is to mark each vertex as visited while\n        avoiding cycles.\n      </p>\n      <p>The DFS algorithm works as follows:</p>\n      <p>\n        1. Start by putting any one of the graph's vertices on top of a stack.\n      </p>\n      <p>2. Take the top item of the stack and add it to the visited list.</p>\n      <p>\n        3. Create a list of that vertex's adjacent nodes. Add the ones which\n        aren't in the visited list to the top of the stack.\n      </p>\n      <p>4. Keep repeating steps 2 and 3 until the stack is empty.</p>\n      <div className=\"divider\"></div>\n      <h3 className=\"sub-title\">Depth First Search Example</h3>\n      <p>\n        Let's see how the Depth First Search algorithm works with an example. We\n        use an undirected graph with 5 vertices.\n      </p>\n      <ImageWrapper\n        url={first}\n        text=\"Undirected graph with 5 vertices\"\n        size=\"md\"\n      />\n      <p>\n        We start from vertex 0, the DFS algorithm starts by putting it in the\n        Visited list and putting all its adjacent vertices in the stack.\n      </p>\n      <ImageWrapper\n        url={second}\n        text=\"Visit the element and put it in the visited list\"\n        size=\"md\"\n      />\n      <p>\n        Next, we visit the element at the top of stack i.e. 1 and go to its\n        adjacent nodes. Since 0 has already been visited, we visit 2 instead.\n      </p>\n      <ImageWrapper\n        url={third}\n        text=\"Visit the element at the top of stack\"\n        size=\"md\"\n      />\n      <p>\n        Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the\n        top of the stack and visit it.\n      </p>\n      <ImageWrapper\n        url={fourth}\n        text=\"Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it.\"\n        size=\"md\"\n      />\n      <ImageWrapper\n        url={fifth}\n        text=\"Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it.\"\n        size=\"md\"\n      />\n      <p>\n        After we visit the last element 3, it doesn't have any unvisited\n        adjacent nodes, so we have completed the Depth First Traversal of the\n        graph.\n      </p>\n      <ImageWrapper\n        url={sixth}\n        text=\"After we visit the last element 3, it doesn't have any unvisited adjacent nodes, so we have completed the Depth First Traversal of the graph.\"\n        size=\"md\"\n      />\n      <div class=\"divider\"></div>\n      <h3 className=\"sub-title\">DFS Pseudocode (recursive implementation)</h3>\n      <p>\n        The pseudocode for DFS is shown below. In the init() function, notice\n        that we run the DFS function on every node. This is because the graph\n        might have two different disconnected parts so to make sure that we\n        cover every vertex, we can also run the DFS algorithm on every node.\n      </p>\n      <CodePreview\n        code={`\n        DFS(G, u)\n        u.visited = true\n        for each v ∈ G.Adj[u]\n            if v.visited == false\n                DFS(G,v)\n       \n        init() {\n            For each u ∈ G\n                u.visited = false\n            For each u ∈ G\n              DFS(G, u)\n        }\n      `}\n        language=\"java\"\n      />\n      <div className=\"divider\"></div>\n      <h3 className=\"sub-title\">DFS Implementation in Java </h3>\n      <p>\n        The code for the Depth First Search Algorithm with an example is shown\n        below. The code has been simplified so that we can focus on the\n        algorithm rather than other details.\n      </p>\n      <CodePreview\n        code={`\n        // DFS algorithm in Java\n\n        import java.util.*;\n        \n        class Graph {\n          private LinkedList<Integer> adjLists[];\n          private boolean visited[];\n        \n          // Graph creation\n          Graph(int vertices) {\n            adjLists = new LinkedList[vertices];\n            visited = new boolean[vertices];\n        \n            for (int i = 0; i < vertices; i++)\n              adjLists[i] = new LinkedList<Integer>();\n          }\n        \n          // Add edges\n          void addEdge(int src, int dest) {\n            adjLists[src].add(dest);\n          }\n        \n          // DFS algorithm\n          void DFS(int vertex) {\n            visited[vertex] = true;\n            System.out.print(vertex + \" \");\n        \n            Iterator<Integer> ite = adjLists[vertex].listIterator();\n            while (ite.hasNext()) {\n              int adj = ite.next();\n              if (!visited[adj])\n                DFS(adj);\n            }\n          }\n        \n          public static void main(String args[]) {\n            Graph g = new Graph(4);\n        \n            g.addEdge(0, 1);\n            g.addEdge(0, 2);\n            g.addEdge(1, 2);\n            g.addEdge(2, 3);\n        \n            System.out.println(\"Following is Depth First Traversal\");\n        \n            g.DFS(2);\n          }\n        }\n        `}\n        language=\"java\"\n      />\n      <div className=\"divider\"></div>\n      <h3 className=\"title\">Dijkstra's Algorithm</h3>\n      <p>\n        Dijkstra's algorithm allows us to find the shortest path between any two\n        vertices of a graph.\n      </p>\n      <p>\n        It differs from the minimum spanning tree because the shortest distance\n        between two vertices might not include all the vertices of the graph.\n      </p>\n      <div className=\"divider\"></div>\n      <h3 className=\"sub-title\">How Dijkstra's Algorithm works</h3>\n      <p>\n        Dijkstra's Algorithm works on the basis that any subpath B {`->`} D of\n        the shortest path A {`->`} D between vertices A and D is also the\n        shortest path between vertices B and D.\n      </p>\n      <ImageWrapper\n        url={seven}\n        text=\"Each subpath is the shortest path\"\n        size=\"md\"\n      />\n      <p>\n        Djikstra used this property in the opposite direction i.e we\n        overestimate the distance of each vertex from the starting vertex. Then\n        we visit each node and its neighbors to find the shortest subpath to\n        those neighbors.\n      </p>\n      <p>\n        The algorithm uses a greedy approach in the sense that we find the next\n        best solution hoping that the end result is the best solution for the\n        whole problem.\n      </p>\n      <div className=\"divider\"></div>\n      <h3 className=\"sub-title\">Example of Dijkstra's algorithm</h3>\n      <p>\n        It is easier to start with an example and then think about the\n        algorithm.\n      </p>\n      <ImageWrapper url={eight} text=\"Start with a weighted graph\" size=\"sm\" />\n      <ImageWrapper\n        url={nine}\n        text=\"Choose a starting vertex and assign infinity path values to all other devices\"\n        size=\"sm\"\n      />\n      <ImageWrapper\n        url={ten}\n        text=\"Go to each vertex and update its path length\"\n        size=\"sm\"\n      />\n      <ImageWrapper\n        url={eleven}\n        text=\"If the path length of the adjacent vertex is lesser than new path length, don't update it\"\n        size=\"sm\"\n      />\n      <ImageWrapper\n        url={twelve}\n        text=\"Avoid updating path lengths of already visited vertices\"\n        size=\"sm\"\n      />\n      <ImageWrapper\n        url={thirteen}\n        text=\"After each iteration, we pick the unvisited vertex with the least path length. So we choose 5 before 7\"\n        size=\"sm\"\n      />\n      <ImageWrapper\n        url={fourteen}\n        text=\"Notice how the rightmost vertex has its path length updated twice\"\n        size=\"sm\"\n      />\n      <ImageWrapper\n        url={fifteen}\n        text=\"Repeat until all the vertices have been visited\"\n        size=\"sm\"\n      />\n      <div className=\"divider\"></div>\n      <h3 className=\"sub-title\">Djikstra's algorithm pseudocode</h3>\n      <p>\n        We need to maintain the path distance of every vertex. We can store that\n        in an array of size v, where v is the number of vertices.\n      </p>\n      <p>\n        We also want to be able to get the shortest path, not only know the\n        length of the shortest path. For this, we map each vertex to the vertex\n        that last updated its path length.\n      </p>\n      <p>\n        Once the algorithm is over, we can backtrack from the destination vertex\n        to the source vertex to find the path.\n      </p>\n      <p>\n        A minimum priority queue can be used to efficiently receive the vertex\n        with least path distance.\n      </p>\n      <CodePreview\n        code={`\n        function dijkstra(G, S)\n          for each vertex V in G\n            distance[V] <- infinite\n            previous[V] <- NULL\n            If V != S, add V to Priority Queue Q\n              distance[S] <- 0\n\t\n            while Q IS NOT EMPTY\n                U <- Extract MIN from Q\n                for each unvisited neighbour V of U\n                    tempDistance <- distance[U] + edge_weight(U, V)\n                    if tempDistance < distance[V]\n                        distance[V] <- tempDistance\n                        previous[V] <- U\n            return distance[], previous[]\n        `}\n        language=\"java\"\n      />\n      <div className=\"divider\"></div>\n      <h3 className=\"sub-title\">Code for Dijkstra's Algorithm</h3>\n      <p>\n        The implementation of Dijkstra's Algorithm in Java is given below. The\n        complexity of the code can be improved, but the abstractions are\n        convenient to relate the code with the algorithm.\n      </p>\n      <CodePreview\n        code={`\n      // Dijkstra's Algorithm in Java\n\n      public class Dijkstra {\n\n        public static void dijkstra(int[][] graph, int source) {\n          int count = graph.length;\n          boolean[] visitedVertex = new boolean[count];\n          int[] distance = new int[count];\n          for (int i = 0; i < count; i++) {\n            visitedVertex[i] = false;\n            distance[i] = Integer.MAX_VALUE;\n          }\n\n          // Distance of self loop is zero\n          distance[source] = 0;\n          for (int i = 0; i < count; i++) {\n\n            // Update the distance between neighbouring vertex and source vertex\n            int u = findMinDistance(distance, visitedVertex);\n            visitedVertex[u] = true;\n\n            // Update all the neighbouring vertex distances\n            for (int v = 0; v < count; v++) {\n              if (!visitedVertex[v] && graph[u][v] != 0 && (distance[u] + graph[u][v] < distance[v])) {\n                distance[v] = distance[u] + graph[u][v];\n              }\n            }\n          }\n          for (int i = 0; i < distance.length; i++) {\n            System.out.println(String.format(\"Distance from %s to %s is %s\", source, i, distance[i]));\n          }\n\n        }\n\n        // Finding the minimum distance\n        private static int findMinDistance(int[] distance, boolean[] visitedVertex) {\n          int minDistance = Integer.MAX_VALUE;\n          int minDistanceVertex = -1;\n          for (int i = 0; i < distance.length; i++) {\n            if (!visitedVertex[i] && distance[i] < minDistance) {\n              minDistance = distance[i];\n              minDistanceVertex = i;\n            }\n          }\n          return minDistanceVertex;\n        }\n\n        public static void main(String[] args) {\n          int graph[][] = new int[][] { { 0, 0, 1, 2, 0, 0, 0 }, { 0, 0, 2, 0, 0, 3, 0 }, { 1, 2, 0, 1, 3, 0, 0 },\n              { 2, 0, 1, 0, 0, 0, 1 }, { 0, 0, 3, 0, 0, 2, 0 }, { 0, 3, 0, 0, 2, 0, 1 }, { 0, 0, 0, 1, 0, 1, 0 } };\n          Dijkstra T = new Dijkstra();\n          T.dijkstra(graph, 0);\n        }\n      }\n        `}\n        language=\"java\"\n      />\n    </div>\n  );\n};\n\nexport default GraphAlgorithms;\n"],"sourceRoot":""}