{"version":3,"sources":["containers/algorythms/PathFinding/pathFindingToolbar.js","containers/algorythms/PathFinding/pathFinding.js","containers/algorythms/PathFinding/Pathfinding-Visualizer-Tutorial/PathfindingVisualizer/Node/Node.jsx","containers/algorythms/PathFinding/Pathfinding-Visualizer-Tutorial/algorithms/dijkstra.js","containers/algorythms/PathFinding/Pathfinding-Visualizer-Tutorial/PathfindingVisualizer/PathfindingVisualizer.jsx","components/pages/Graph/GraphExample.js"],"names":["Toolbar","props","AppBar","style","backgroundColor","position","Grid","container","alignItems","spacing","marginTop","marginBottom","item","FormControl","minWidth","InputLabel","htmlFor","Select","value","algorithm","onChange","handleAlgorithmChange","inputProps","name","id","algorithms","map","MenuItem","key","FormControlLabel","control","Switch","checked","allowDiagonal","handleAllowDiagonalChange","label","editMode","handleEditModeChange","getIndexFromPosition","x","y","size","getPathFinder","_memoize","PF","getPositionsAreEqual","a","b","computeTiles","start","end","matrix","tiles","_flatten","matrixJs","trans","column","walkable","i","inPath","isStart","isEnd","getTilesFromMatrix","pathFinder","grid","getGridFromMatrix","findPath","forEach","initialState","pathSet","reducer","state","action","type","tile","GameContainer","styled","div","GridContainer","Paper","Tile","TileIcon","color","getIconColor","fontSize","App","useImmerReducer","dispatch","CssBaseline","e","target","onClick","onMouseEnter","Node","this","col","isFinish","isWall","onMouseDown","onMouseUp","row","extraClassName","className","Component","dijkstra","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","PathfindingVisualizer","mouseIsPressed","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","setTimeout","animateShortestPath","document","getElementById","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","visualizeDijkstra","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","GraphExample"],"mappings":"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","file":"static/js/11.29a8f051.chunk.js","sourcesContent":["import React from \"react\"\nimport AppBar from \"@material-ui/core/AppBar\"\nimport MuiToolbar from \"@material-ui/core/Toolbar\"\nimport FormControlLabel from \"@material-ui/core/FormControlLabel\"\nimport Switch from \"@material-ui/core/Switch\"\nimport FormControl from \"@material-ui/core/FormControl\"\nimport InputLabel from \"@material-ui/core/InputLabel\"\nimport Select from \"@material-ui/core/Select\"\nimport MenuItem from \"@material-ui/core/MenuItem\"\nimport Grid from \"@material-ui/core/Grid\"\n\nexport const Toolbar = (props) => (\n  <AppBar style={{ backgroundColor: \"#1890ff\", position: \"static\" }}>\n    <MuiToolbar>\n      <Grid\n        container\n        alignItems='flex-end'\n        spacing={2}\n        style={{ marginTop: 8, marginBottom: 8 }}>\n        <Grid item>\n          <FormControl style={{ minWidth: 200 }}>\n            <InputLabel htmlFor='algorithm-select'>Algorithm</InputLabel>\n            <Select\n              value={props.algorithm}\n              onChange={props.handleAlgorithmChange}\n              inputProps={{\n                name: \"algorithm-select\",\n                id: \"algorithm-select\",\n              }}>\n              {props.algorithms.map((algorithm) => (\n                <MenuItem value={algorithm} key={algorithm}>\n                  {algorithm}\n                </MenuItem>\n              ))}\n            </Select>\n          </FormControl>\n        </Grid>\n        <Grid item>\n          <FormControl>\n            <FormControlLabel\n              control={\n                <Switch\n                  checked={props.allowDiagonal}\n                  onChange={props.handleAllowDiagonalChange}\n                />\n              }\n              label='Allow Diagonal'\n            />\n          </FormControl>\n        </Grid>\n        <Grid item>\n          <FormControl>\n            <FormControlLabel\n              control={\n                <Switch\n                  checked={props.editMode}\n                  onChange={props.handleEditModeChange}\n                />\n              }\n              label='Edit Walkable'\n            />\n          </FormControl>\n        </Grid>\n      </Grid>\n    </MuiToolbar>\n  </AppBar>\n)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport { useImmerReducer } from \"use-immer\"\nimport styled from \"styled-components\"\nimport { createMuiTheme } from \"@material-ui/core/styles\"\nimport Paper from \"@material-ui/core/Paper\"\nimport CssBaseline from \"@material-ui/core/CssBaseline\"\nimport StarIcon from \"@material-ui/icons/Star\"\nimport StarOutlinedIcon from \"@material-ui/icons/StarBorder\"\nimport _flatten from \"lodash/flatten\"\nimport _memoize from \"lodash/memoize\"\nimport PF from \"pathfinding\"\nimport matrixJs from \"matrix-js\"\n\nimport { Toolbar } from \"./pathFindingToolbar\"\n\nconst algorithms = [\n  \"AStarFinder\",\n  \"BestFirstFinder\",\n  \"BreadthFirstFinder\",\n  \"DijkstraFinder\",\n  \"IDAStarFinder\",\n  \"JumpPointFinder\",\n  \"BiAStarFinder\",\n  \"BiBestFirstFinder\",\n  \"BiBreadthFirstFinder\",\n  \"BiDijkstraFinder\",\n]\n\n// A matrix of the game map. 1 for non-walkable; 0 for walkable\nconst size = 8\nconst matrix = [\n  [1, 0, 0, 0, 0, 0, 0, 0],\n  [1, 0, 0, 0, 0, 1, 1, 0],\n  [1, 1, 0, 1, 0, 0, 1, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0],\n  [0, 1, 0, 1, 0, 0, 0, 0],\n  [0, 1, 0, 0, 1, 0, 0, 0],\n  [0, 1, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 1],\n]\n\nfunction getIndexFromPosition(x, y, size) {\n  return x * size + y\n}\n\n// For future reference\n// function getPositionFromIndex(i, size) {\n//   return {\n//     x: Math.floor(i / size),\n//     y: i % size\n//   };\n// }\n\n// create a \"grid\" from the original matrix\nfunction getGridFromMatrix({ matrix }) {\n  return new PF.Grid([...matrix])\n}\n\n// Convert the matrix above to a flat array of tile objects\n// with their x,y position and own index\nfunction getTilesFromMatrix({ matrix }) {\n  return _flatten(\n    // Flatten the result of...\n    matrixJs(matrix) // The matrix utility so we can...\n      .trans() // Transpose (rotate 90 degrees) so it's not weird\n      .map((column, x) =>\n        column.map((value, y) => ({\n          x, // the column\n          y, // the row\n          walkable: !value, // 0 for walkable, 1 for not\n          i: getIndexFromPosition(x, y), // the correct index number\n          inPath: false, // no path yet!\n          isStart: false, // no starting tile yet!\n          isEnd: false, // no ending tile yet!\n        }))\n      )\n  )\n}\n\nconst getPathFinder = _memoize(\n  ({ algorithm, allowDiagonal }) => {\n    return new PF[algorithm]({\n      allowDiagonal,\n    })\n  },\n  ({ algorithm, allowDiagonal }) => algorithm + allowDiagonal\n)\n\nfunction getPositionsAreEqual(a, b) {\n  return a && b && a.x === b.x && a.y === b.y\n}\n\nfunction computeTiles({ start, end, algorithm, allowDiagonal, matrix }) {\n  const tiles = getTilesFromMatrix({ matrix })\n  if (start) {\n    tiles[getIndexFromPosition(start.x, start.y, size)].isStart = true\n  }\n  if (end) {\n    tiles[getIndexFromPosition(end.x, end.y, size)].isEnd = true\n  }\n  if (start && end) {\n    const pathFinder = getPathFinder({ algorithm, allowDiagonal })\n    const grid = getGridFromMatrix({ matrix })\n    const path = pathFinder.findPath(start.x, start.y, end.x, end.y, grid)\n    path.forEach(([x, y]) => {\n      tiles[getIndexFromPosition(x, y, size)].inPath = true\n    })\n  }\n  return tiles\n}\n\nconst initialState = {\n  start: null, // starting tile for pathfinding\n  end: null, // ending tile\n  pathSet: false,\n  algorithm: \"AStarFinder\", // the pathfinding algorithm to use\n  allowDiagonal: true, // optionally allow diagonal paths\n  matrix,\n  editMode: false,\n}\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"tile clicked\": {\n      const { tile } = action\n      if (state.editMode) {\n        const matrixTile = (state.matrix[tile.y][tile.x] ^= 1)\n        if (\n          matrixTile &&\n          (getPositionsAreEqual(state.end, tile) ||\n            getPositionsAreEqual(state.start, tile))\n        ) {\n          state.start = null\n          state.end = null\n          state.pathSet = false\n        }\n      } else if (state.pathSet && tile.walkable) {\n        state.pathSet = false\n        state.start = tile\n        state.end = null\n      } else if (state.start && tile.walkable) {\n        state.pathSet = true\n      } else if (tile.walkable) {\n        state.start = tile\n      }\n      return\n    }\n\n    case \"mouse entered tile\": {\n      const { tile } = action\n      if (\n        !state.editMode &&\n        !state.pathSet &&\n        state.start &&\n        tile.walkable &&\n        !tile.isStart\n      ) {\n        state.end = tile\n      }\n      return\n    }\n\n    case \"algorithm changed\": {\n      state.algorithm = action.algorithm\n      return\n    }\n\n    case \"allow diagonal toggled\": {\n      state.allowDiagonal = !state.allowDiagonal\n      return\n    }\n\n    case \"edit mode toggled\": {\n      state.editMode = !state.editMode\n      return\n    }\n\n    default:\n      return state\n  }\n}\n\nfunction App() {\n  const [state, dispatch] = useImmerReducer(reducer, initialState)\n  const tiles = computeTiles(state)\n\n  return (\n    <>\n      <CssBaseline />\n      <Toolbar\n        algorithm={state.algorithm}\n        algorithms={algorithms}\n        handleAlgorithmChange={(e) =>\n          dispatch({ type: \"algorithm changed\", algorithm: e.target.value })\n        }\n        allowDiagonal={state.allowDiagonal}\n        handleAllowDiagonalChange={() =>\n          dispatch({ type: \"allow diagonal toggled\" })\n        }\n        handleEditModeChange={() => dispatch({ type: \"edit mode toggled\" })}\n      />\n      <GameContainer>\n        {/* <div style={{ flex: 1 }} /> */}\n        <GridContainer>\n          {tiles.map((tile, i) => (\n            <Tile\n              key={i}\n              tile={tile}\n              onClick={() => dispatch({ type: \"tile clicked\", tile })}\n              onMouseEnter={() =>\n                dispatch({ type: \"mouse entered tile\", tile })\n              }\n              editMode={state.editMode}>\n              <TileIcon tile={tile} pathSet={state.pathSet} />\n            </Tile>\n          ))}\n        </GridContainer>\n      </GameContainer>\n    </>\n  )\n}\n\nconst GameContainer = styled.div`\n  display: flex;\n  margin: 120px 24px;\n`\n\nconst GridContainer = styled(Paper)`\n  display: grid;\n  grid-template-rows: repeat(8, 64px);\n  grid-auto-flow: column;\n  grid-auto-columns: 64px;\n  grid-auto-rows: 64px;\n`\n\nfunction getHoverColor({ editMode, tile }) {\n  if (editMode) {\n    return tile.walkable ? \"rgba(0,0,0,0.4)\" : \"rgba(0,0,0,0.6)\"\n  } else {\n    return tile.walkable ? \"rgba(255,255,255,0.2)\" : \"#1890ff\"\n  }\n}\n\nconst Tile = styled.div`\n  border-bottom: 1px solid black;\n  border-right: 1px solid black;\n  background-color: ${(props) =>\n    props.tile.walkable ? \"transparent\" : \"#1890ff\"};\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);\n  user-select: none;\n  &:hover {\n    background-color: ${getHoverColor};\n  }\n`\n\nfunction getIconColor(tile) {\n  if (tile.isStart) {\n    return \"Chartreuse\"\n  } else if (tile.isEnd) {\n    return \"OrangeRed\"\n  } else if (tile.inPath) {\n    return \"CornflowerBlue\"\n  } else {\n    return \"AntiqueWhite\"\n  }\n}\n\nfunction TileIcon({ tile, pathSet }) {\n  if (tile.isStart || tile.inPath || tile.isEnd) {\n    const color = getIconColor(tile)\n    if (tile.isEnd && !pathSet) {\n      return <StarOutlinedIcon fontSize='large' style={{ color }} />\n    } else {\n      return <StarIcon fontSize='large' style={{ color }} />\n    }\n  }\n  return null\n}\n\nexport default App\n","import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n    } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { Component } from \"react\"\nimport Node from \"./Node/Node\"\nimport \"../App.css\"\nimport \"../index.css\"\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\"\n\nimport \"./PathfindingVisualizer.css\"\n\nconst START_NODE_ROW = 10\nconst START_NODE_COL = 15\nconst FINISH_NODE_ROW = 10\nconst FINISH_NODE_COL = 35\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super()\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    }\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid()\n    this.setState({ grid })\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col)\n    this.setState({ grid: newGrid, mouseIsPressed: true })\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col)\n    this.setState({ grid: newGrid })\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false })\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder)\n        }, 10 * i)\n        return\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i]\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\"\n      }, 10 * i)\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i]\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\"\n      }, 50 * i)\n    }\n  }\n\n  visualizeDijkstra() {\n    const { grid } = this.state\n    const startNode = grid[START_NODE_ROW][START_NODE_COL]\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode)\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode)\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder)\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state\n\n    return (\n      <>\n        <button\n          className='dijkstra-btn'\n          onClick={() => this.visualizeDijkstra()}>\n          Visualize Dijkstra's Algorithm\n        </button>\n        <div className='grid'>\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}></Node>\n                  )\n                })}\n              </div>\n            )\n          })}\n        </div>\n      </>\n    )\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = []\n  for (let row = 0; row < 20; row++) {\n    const currentRow = []\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row))\n    }\n    grid.push(currentRow)\n  }\n  return grid\n}\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  }\n}\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice()\n  const node = newGrid[row][col]\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  }\n  newGrid[row][col] = newNode\n  return newGrid\n}\n","import React from \"react\"\nimport App from \"../../../containers/algorythms/PathFinding/pathFinding\"\nimport PathfindingVisualizer from \"../../../containers/algorythms/PathFinding/Pathfinding-Visualizer-Tutorial/PathfindingVisualizer/PathfindingVisualizer\"\n\nconst GraphExample = () => {\n  return (\n    <div className='container'>\n      <h3 className='title'>Here examples how graph algorithms work</h3>\n      <App />\n      <div className='divider'></div>\n      <h3 className='sub-title'>Another example</h3>\n      <PathfindingVisualizer />\n    </div>\n  )\n}\n\nexport default GraphExample\n"],"sourceRoot":""}